/**
* Generated by go-doudou v2.0.8.
* Don't edit!
 */
package client

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"testgorm/dto"

	"github.com/go-resty/resty/v2"
	"github.com/klauspost/compress/gzip"
	"github.com/opentracing-contrib/go-stdlib/nethttp"
	"github.com/opentracing/opentracing-go"
	"github.com/pkg/errors"
	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
	"github.com/unionj-cloud/go-doudou/v2/framework/rest"
	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
)

type TestgormClient struct {
	provider registry.IServiceProvider
	client   *resty.Client
	rootPath string
}

func (receiver *TestgormClient) SetRootPath(rootPath string) {
	receiver.rootPath = rootPath
}

func (receiver *TestgormClient) SetProvider(provider registry.IServiceProvider) {
	receiver.provider = provider
}

func (receiver *TestgormClient) SetClient(client *resty.Client) {
	receiver.client = client
}
func (receiver *TestgormClient) PostCadCommonComment(ctx context.Context, _headers map[string]string, body dto.CadCommonComment, options Options) (_resp *resty.Response, data string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/cad/common/comment"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data string `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetCadCommonComment_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, data dto.CadCommonComment, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/cad/common/comment/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.CadCommonComment `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutCadCommonComment(ctx context.Context, _headers map[string]string, body dto.CadCommonComment, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/cad/common/comment"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteCadCommonComment_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/cad/common/comment/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetCadCommonComments(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/cad/common/comments"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PostCadCommonLike(ctx context.Context, _headers map[string]string, body dto.CadCommonLike, options Options) (_resp *resty.Response, data string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/cad/common/like"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data string `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetCadCommonLike_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, data dto.CadCommonLike, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/cad/common/like/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.CadCommonLike `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutCadCommonLike(ctx context.Context, _headers map[string]string, body dto.CadCommonLike, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/cad/common/like"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteCadCommonLike_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/cad/common/like/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetCadCommonLikes(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/cad/common/likes"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PostQrtzJobDetail(ctx context.Context, _headers map[string]string, body dto.QrtzJobDetail, options Options) (_resp *resty.Response, data string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/qrtz/job/detail"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data string `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetQrtzJobDetail_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, data dto.QrtzJobDetail, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/qrtz/job/detail/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.QrtzJobDetail `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutQrtzJobDetail(ctx context.Context, _headers map[string]string, body dto.QrtzJobDetail, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/qrtz/job/detail"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteQrtzJobDetail_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/qrtz/job/detail/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetQrtzJobDetails(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/qrtz/job/details"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PostTInvalidToken(ctx context.Context, _headers map[string]string, body dto.TInvalidToken, options Options) (_resp *resty.Response, data int32, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/t/invalid/token"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data int32 `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetTInvalidToken_Id(ctx context.Context, _headers map[string]string, id int32, options Options) (_resp *resty.Response, data dto.TInvalidToken, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/t/invalid/token/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.TInvalidToken `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutTInvalidToken(ctx context.Context, _headers map[string]string, body dto.TInvalidToken, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/t/invalid/token"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteTInvalidToken_Id(ctx context.Context, _headers map[string]string, id int32, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/t/invalid/token/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetTInvalidTokens(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/t/invalid/tokens"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PostCadCommonConfig(ctx context.Context, _headers map[string]string, body dto.CadCommonConfig, options Options) (_resp *resty.Response, data string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/cad/common/config"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data string `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetCadCommonConfig_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, data dto.CadCommonConfig, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/cad/common/config/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.CadCommonConfig `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutCadCommonConfig(ctx context.Context, _headers map[string]string, body dto.CadCommonConfig, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/cad/common/config"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteCadCommonConfig_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/cad/common/config/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetCadCommonConfigs(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/cad/common/configs"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PostQrtzBlobTrigger(ctx context.Context, _headers map[string]string, body dto.QrtzBlobTrigger, options Options) (_resp *resty.Response, data string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/qrtz/blob/trigger"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data string `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetQrtzBlobTrigger_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, data dto.QrtzBlobTrigger, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/qrtz/blob/trigger/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.QrtzBlobTrigger `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutQrtzBlobTrigger(ctx context.Context, _headers map[string]string, body dto.QrtzBlobTrigger, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/qrtz/blob/trigger"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteQrtzBlobTrigger_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/qrtz/blob/trigger/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetQrtzBlobTriggers(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/qrtz/blob/triggers"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PostQrtzCalendar(ctx context.Context, _headers map[string]string, body dto.QrtzCalendar, options Options) (_resp *resty.Response, data string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/qrtz/calendar"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data string `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetQrtzCalendar_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, data dto.QrtzCalendar, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/qrtz/calendar/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.QrtzCalendar `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutQrtzCalendar(ctx context.Context, _headers map[string]string, body dto.QrtzCalendar, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/qrtz/calendar"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteQrtzCalendar_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/qrtz/calendar/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetQrtzCalendars(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/qrtz/calendars"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PostTUser(ctx context.Context, _headers map[string]string, body dto.TUser, options Options) (_resp *resty.Response, data int32, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/t/user"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data int32 `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetTUser_Id(ctx context.Context, _headers map[string]string, id int32, options Options) (_resp *resty.Response, data dto.TUser, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/t/user/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.TUser `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutTUser(ctx context.Context, _headers map[string]string, body dto.TUser, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/t/user"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteTUser_Id(ctx context.Context, _headers map[string]string, id int32, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/t/user/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetTUsers(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/t/users"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PostTWordCloudTask(ctx context.Context, _headers map[string]string, body dto.TWordCloudTask, options Options) (_resp *resty.Response, data int32, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/t/word/cloud/task"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data int32 `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetTWordCloudTask_Id(ctx context.Context, _headers map[string]string, id int32, options Options) (_resp *resty.Response, data dto.TWordCloudTask, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/t/word/cloud/task/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.TWordCloudTask `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutTWordCloudTask(ctx context.Context, _headers map[string]string, body dto.TWordCloudTask, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/t/word/cloud/task"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteTWordCloudTask_Id(ctx context.Context, _headers map[string]string, id int32, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/t/word/cloud/task/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetTWordCloudTasks(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/t/word/cloud/tasks"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PostCadCommonFile(ctx context.Context, _headers map[string]string, body dto.CadCommonFile, options Options) (_resp *resty.Response, data string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/cad/common/file"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data string `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetCadCommonFile_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, data dto.CadCommonFile, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/cad/common/file/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.CadCommonFile `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutCadCommonFile(ctx context.Context, _headers map[string]string, body dto.CadCommonFile, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/cad/common/file"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteCadCommonFile_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/cad/common/file/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetCadCommonFiles(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/cad/common/files"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PostCadCommonFollow(ctx context.Context, _headers map[string]string, body dto.CadCommonFollow, options Options) (_resp *resty.Response, data string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/cad/common/follow"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data string `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetCadCommonFollow_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, data dto.CadCommonFollow, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/cad/common/follow/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.CadCommonFollow `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutCadCommonFollow(ctx context.Context, _headers map[string]string, body dto.CadCommonFollow, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/cad/common/follow"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteCadCommonFollow_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/cad/common/follow/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetCadCommonFollows(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/cad/common/follows"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PostQrtzFiredTrigger(ctx context.Context, _headers map[string]string, body dto.QrtzFiredTrigger, options Options) (_resp *resty.Response, data string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/qrtz/fired/trigger"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data string `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetQrtzFiredTrigger_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, data dto.QrtzFiredTrigger, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/qrtz/fired/trigger/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.QrtzFiredTrigger `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutQrtzFiredTrigger(ctx context.Context, _headers map[string]string, body dto.QrtzFiredTrigger, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/qrtz/fired/trigger"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteQrtzFiredTrigger_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/qrtz/fired/trigger/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetQrtzFiredTriggers(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/qrtz/fired/triggers"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PostTClient(ctx context.Context, _headers map[string]string, body dto.TClient, options Options) (_resp *resty.Response, data int32, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/t/client"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data int32 `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetTClient_Id(ctx context.Context, _headers map[string]string, id int32, options Options) (_resp *resty.Response, data dto.TClient, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/t/client/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.TClient `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutTClient(ctx context.Context, _headers map[string]string, body dto.TClient, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/t/client"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteTClient_Id(ctx context.Context, _headers map[string]string, id int32, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/t/client/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetTClients(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/t/clients"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PostQrtzCronTrigger(ctx context.Context, _headers map[string]string, body dto.QrtzCronTrigger, options Options) (_resp *resty.Response, data string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/qrtz/cron/trigger"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data string `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) GetQrtzCronTrigger_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, data dto.QrtzCronTrigger, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/qrtz/cron/trigger/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.QrtzCronTrigger `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}
func (receiver *TestgormClient) PutQrtzCronTrigger(ctx context.Context, _headers map[string]string, body dto.QrtzCronTrigger, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(body)
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				re = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(re)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(body)
	}
	_path := "/qrtz/cron/trigger"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) DeleteQrtzCronTrigger_Id(ctx context.Context, _headers map[string]string, id string, options Options) (_resp *resty.Response, re error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/qrtz/cron/trigger/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		re = errors.New(_resp.String())
		return
	}
	var _result struct {
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		re = errors.Wrap(_err, "error")
		return
	}
	return _resp, nil
}
func (receiver *TestgormClient) GetQrtzCronTriggers(ctx context.Context, _headers map[string]string, parameter dto.Parameter, options Options) (_resp *resty.Response, data dto.Page, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	parameterUrlValues, _err := rest.EncodeForm(&parameter)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	_req.SetQueryParamsFromValues(parameterUrlValues)
	_path := "/qrtz/cron/triggers"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Data dto.Page `json:"data"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Data, nil
}

func NewTestgormClient(opts ...restclient.RestClientOption) *TestgormClient {
	defaultProvider := restclient.NewServiceProvider("TESTGORM")
	defaultClient := restclient.NewClient()

	svcClient := &TestgormClient{
		provider: defaultProvider,
		client:   defaultClient,
	}

	for _, opt := range opts {
		opt(svcClient)
	}

	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
		return nil
	})

	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
		*request = *traceReq
		return nil
	})

	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
		return nil
	})

	return svcClient
}
