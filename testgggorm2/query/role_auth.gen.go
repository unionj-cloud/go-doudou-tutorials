// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"github.com/unionj-cloud/go-doudou/v2/toolkit/gormgen"
	"github.com/unionj-cloud/go-doudou/v2/toolkit/gormgen/field"

	"gorm.io/plugin/dbresolver"

	"testgggorm2/model"
)

func newRoleAuth(db *gorm.DB, opts ...gormgen.DOOption) roleAuth {
	_roleAuth := roleAuth{}

	_roleAuth.roleAuthDo.UseDB(db, opts...)
	_roleAuth.roleAuthDo.UseModel(&model.RoleAuth{})

	tableName := _roleAuth.roleAuthDo.TableName()
	_roleAuth.ALL = field.NewAsterisk(tableName)
	_roleAuth.AuthID = field.NewInt32(tableName, "auth_id")
	_roleAuth.RoleID = field.NewInt32(tableName, "role_id")

	_roleAuth.fillFieldMap()

	return _roleAuth
}

type roleAuth struct {
	roleAuthDo roleAuthDo

	ALL    field.Asterisk
	AuthID field.Int32 // 权限编号
	RoleID field.Int32 // 角色编号

	fieldMap map[string]field.Expr
}

func (r roleAuth) Table(newTableName string) *roleAuth {
	r.roleAuthDo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r roleAuth) As(alias string) *roleAuth {
	r.roleAuthDo.DO = *(r.roleAuthDo.As(alias).(*gormgen.DO))
	return r.updateTableName(alias)
}

func (r *roleAuth) updateTableName(table string) *roleAuth {
	r.ALL = field.NewAsterisk(table)
	r.AuthID = field.NewInt32(table, "auth_id")
	r.RoleID = field.NewInt32(table, "role_id")

	r.fillFieldMap()

	return r
}

func (r *roleAuth) WithContext(ctx context.Context) IRoleAuthDo { return r.roleAuthDo.WithContext(ctx) }

func (r roleAuth) TableName() string { return r.roleAuthDo.TableName() }

func (r roleAuth) Alias() string { return r.roleAuthDo.Alias() }

func (r roleAuth) Columns(cols ...field.Expr) gormgen.Columns { return r.roleAuthDo.Columns(cols...) }

func (r *roleAuth) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *roleAuth) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 2)
	r.fieldMap["auth_id"] = r.AuthID
	r.fieldMap["role_id"] = r.RoleID
}

func (r roleAuth) clone(db *gorm.DB) roleAuth {
	r.roleAuthDo.ReplaceConnPool(db.Statement.ConnPool)
	return r
}

func (r roleAuth) replaceDB(db *gorm.DB) roleAuth {
	r.roleAuthDo.ReplaceDB(db)
	return r
}

type roleAuthDo struct{ gormgen.DO }

type IRoleAuthDo interface {
	gormgen.SubQuery
	Debug() IRoleAuthDo
	WithContext(ctx context.Context) IRoleAuthDo
	WithResult(fc func(tx gormgen.Dao)) gormgen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IRoleAuthDo
	WriteDB() IRoleAuthDo
	As(alias string) gormgen.Dao
	Session(config *gorm.Session) IRoleAuthDo
	Columns(cols ...field.Expr) gormgen.Columns
	Clauses(conds ...clause.Expression) IRoleAuthDo
	Not(conds ...gormgen.Condition) IRoleAuthDo
	Or(conds ...gormgen.Condition) IRoleAuthDo
	Select(conds ...field.Expr) IRoleAuthDo
	Where(conds ...gormgen.Condition) IRoleAuthDo
	Order(conds ...field.Expr) IRoleAuthDo
	Distinct(cols ...field.Expr) IRoleAuthDo
	Omit(cols ...field.Expr) IRoleAuthDo
	Join(table schema.Tabler, on ...field.Expr) IRoleAuthDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IRoleAuthDo
	RightJoin(table schema.Tabler, on ...field.Expr) IRoleAuthDo
	Group(cols ...field.Expr) IRoleAuthDo
	Having(conds ...gormgen.Condition) IRoleAuthDo
	Limit(limit int) IRoleAuthDo
	Offset(offset int) IRoleAuthDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gormgen.Dao) gormgen.Dao) IRoleAuthDo
	Unscoped() IRoleAuthDo
	Create(values ...*model.RoleAuth) error
	CreateInBatches(values []*model.RoleAuth, batchSize int) error
	Save(values ...*model.RoleAuth) error
	First() (*model.RoleAuth, error)
	Take() (*model.RoleAuth, error)
	Last() (*model.RoleAuth, error)
	Find() ([]*model.RoleAuth, error)
	FindInBatch(batchSize int, fc func(tx gormgen.Dao, batch int) error) (results []*model.RoleAuth, err error)
	FindInBatches(result *[]*model.RoleAuth, batchSize int, fc func(tx gormgen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.RoleAuth) (info gormgen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gormgen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gormgen.ResultInfo, err error)
	Updates(value interface{}) (info gormgen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gormgen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gormgen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gormgen.ResultInfo, err error)
	UpdateFrom(q gormgen.SubQuery) gormgen.Dao
	Attrs(attrs ...field.AssignExpr) IRoleAuthDo
	Assign(attrs ...field.AssignExpr) IRoleAuthDo
	Joins(fields ...field.RelationField) IRoleAuthDo
	Preload(fields ...field.RelationField) IRoleAuthDo
	FirstOrInit() (*model.RoleAuth, error)
	FirstOrCreate() (*model.RoleAuth, error)
	FindByPage(offset int, limit int) (result []*model.RoleAuth, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IRoleAuthDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (r roleAuthDo) Debug() IRoleAuthDo {
	return r.withDO(r.DO.Debug())
}

func (r roleAuthDo) WithContext(ctx context.Context) IRoleAuthDo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r roleAuthDo) ReadDB() IRoleAuthDo {
	return r.Clauses(dbresolver.Read)
}

func (r roleAuthDo) WriteDB() IRoleAuthDo {
	return r.Clauses(dbresolver.Write)
}

func (r roleAuthDo) Session(config *gorm.Session) IRoleAuthDo {
	return r.withDO(r.DO.Session(config))
}

func (r roleAuthDo) Clauses(conds ...clause.Expression) IRoleAuthDo {
	return r.withDO(r.DO.Clauses(conds...))
}

func (r roleAuthDo) Returning(value interface{}, columns ...string) IRoleAuthDo {
	return r.withDO(r.DO.Returning(value, columns...))
}

func (r roleAuthDo) Not(conds ...gormgen.Condition) IRoleAuthDo {
	return r.withDO(r.DO.Not(conds...))
}

func (r roleAuthDo) Or(conds ...gormgen.Condition) IRoleAuthDo {
	return r.withDO(r.DO.Or(conds...))
}

func (r roleAuthDo) Select(conds ...field.Expr) IRoleAuthDo {
	return r.withDO(r.DO.Select(conds...))
}

func (r roleAuthDo) Where(conds ...gormgen.Condition) IRoleAuthDo {
	return r.withDO(r.DO.Where(conds...))
}

func (r roleAuthDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IRoleAuthDo {
	return r.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (r roleAuthDo) Order(conds ...field.Expr) IRoleAuthDo {
	return r.withDO(r.DO.Order(conds...))
}

func (r roleAuthDo) Distinct(cols ...field.Expr) IRoleAuthDo {
	return r.withDO(r.DO.Distinct(cols...))
}

func (r roleAuthDo) Omit(cols ...field.Expr) IRoleAuthDo {
	return r.withDO(r.DO.Omit(cols...))
}

func (r roleAuthDo) Join(table schema.Tabler, on ...field.Expr) IRoleAuthDo {
	return r.withDO(r.DO.Join(table, on...))
}

func (r roleAuthDo) LeftJoin(table schema.Tabler, on ...field.Expr) IRoleAuthDo {
	return r.withDO(r.DO.LeftJoin(table, on...))
}

func (r roleAuthDo) RightJoin(table schema.Tabler, on ...field.Expr) IRoleAuthDo {
	return r.withDO(r.DO.RightJoin(table, on...))
}

func (r roleAuthDo) Group(cols ...field.Expr) IRoleAuthDo {
	return r.withDO(r.DO.Group(cols...))
}

func (r roleAuthDo) Having(conds ...gormgen.Condition) IRoleAuthDo {
	return r.withDO(r.DO.Having(conds...))
}

func (r roleAuthDo) Limit(limit int) IRoleAuthDo {
	return r.withDO(r.DO.Limit(limit))
}

func (r roleAuthDo) Offset(offset int) IRoleAuthDo {
	return r.withDO(r.DO.Offset(offset))
}

func (r roleAuthDo) Scopes(funcs ...func(gormgen.Dao) gormgen.Dao) IRoleAuthDo {
	return r.withDO(r.DO.Scopes(funcs...))
}

func (r roleAuthDo) Unscoped() IRoleAuthDo {
	return r.withDO(r.DO.Unscoped())
}

func (r roleAuthDo) Create(values ...*model.RoleAuth) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Create(values)
}

func (r roleAuthDo) CreateInBatches(values []*model.RoleAuth, batchSize int) error {
	return r.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (r roleAuthDo) Save(values ...*model.RoleAuth) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Save(values)
}

func (r roleAuthDo) First() (*model.RoleAuth, error) {
	if result, err := r.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.RoleAuth), nil
	}
}

func (r roleAuthDo) Take() (*model.RoleAuth, error) {
	if result, err := r.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.RoleAuth), nil
	}
}

func (r roleAuthDo) Last() (*model.RoleAuth, error) {
	if result, err := r.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.RoleAuth), nil
	}
}

func (r roleAuthDo) Find() ([]*model.RoleAuth, error) {
	result, err := r.DO.Find()
	return result.([]*model.RoleAuth), err
}

func (r roleAuthDo) FindInBatch(batchSize int, fc func(tx gormgen.Dao, batch int) error) (results []*model.RoleAuth, err error) {
	buf := make([]*model.RoleAuth, 0, batchSize)
	err = r.DO.FindInBatches(&buf, batchSize, func(tx gormgen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (r roleAuthDo) FindInBatches(result *[]*model.RoleAuth, batchSize int, fc func(tx gormgen.Dao, batch int) error) error {
	return r.DO.FindInBatches(result, batchSize, fc)
}

func (r roleAuthDo) Attrs(attrs ...field.AssignExpr) IRoleAuthDo {
	return r.withDO(r.DO.Attrs(attrs...))
}

func (r roleAuthDo) Assign(attrs ...field.AssignExpr) IRoleAuthDo {
	return r.withDO(r.DO.Assign(attrs...))
}

func (r roleAuthDo) Joins(fields ...field.RelationField) IRoleAuthDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Joins(_f))
	}
	return &r
}

func (r roleAuthDo) Preload(fields ...field.RelationField) IRoleAuthDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Preload(_f))
	}
	return &r
}

func (r roleAuthDo) FirstOrInit() (*model.RoleAuth, error) {
	if result, err := r.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.RoleAuth), nil
	}
}

func (r roleAuthDo) FirstOrCreate() (*model.RoleAuth, error) {
	if result, err := r.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.RoleAuth), nil
	}
}

func (r roleAuthDo) FindByPage(offset int, limit int) (result []*model.RoleAuth, count int64, err error) {
	result, err = r.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = r.Offset(-1).Limit(-1).Count()
	return
}

func (r roleAuthDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = r.Count()
	if err != nil {
		return
	}

	err = r.Offset(offset).Limit(limit).Scan(result)
	return
}

func (r roleAuthDo) Scan(result interface{}) (err error) {
	return r.DO.Scan(result)
}

func (r roleAuthDo) Delete(models ...*model.RoleAuth) (result gormgen.ResultInfo, err error) {
	return r.DO.Delete(models)
}

func (r *roleAuthDo) withDO(do gormgen.Dao) *roleAuthDo {
	r.DO = *do.(*gormgen.DO)
	return r
}
