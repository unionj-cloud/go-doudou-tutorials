/**
* Generated by go-doudou v2.0.5.
* Don't edit!
 */
package client

import (
	"context"
	"encoding/json"
	"fmt"
	"gin2doudou/dto"
	"io"
	"net/http"
	"net/url"

	"github.com/go-resty/resty/v2"
	"github.com/klauspost/compress/gzip"
	"github.com/opentracing-contrib/go-stdlib/nethttp"
	"github.com/opentracing/opentracing-go"
	"github.com/pkg/errors"
	"github.com/unionj-cloud/go-doudou/v2/framework/registry"
	"github.com/unionj-cloud/go-doudou/v2/framework/restclient"
)

type Gin2DoudouClient struct {
	provider registry.IServiceProvider
	client   *resty.Client
	rootPath string
}

func (receiver *Gin2DoudouClient) SetRootPath(rootPath string) {
	receiver.rootPath = rootPath
}

func (receiver *Gin2DoudouClient) SetProvider(provider registry.IServiceProvider) {
	receiver.provider = provider
}

func (receiver *Gin2DoudouClient) SetClient(client *resty.Client) {
	receiver.client = client
}
func (receiver *Gin2DoudouClient) ApiV1Menus(ctx context.Context, _headers map[string]string, bodyJSON dto.SchemaMenu, options Options) (_resp *resty.Response, ret dto.SchemaIDResult, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(bodyJSON)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(bodyJSON)
	}
	_path := "/api/v1/menus"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaIDResult `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) ApiV1PubLogin(ctx context.Context, _headers map[string]string, bodyJSON dto.SchemaLoginParam, options Options) (_resp *resty.Response, ret dto.SchemaLoginTokenInfo, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(bodyJSON)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(bodyJSON)
	}
	_path := "/api/v1/pub/login"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaLoginTokenInfo `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) ApiV1PubLoginExit(ctx context.Context, _headers map[string]string, options Options) (_resp *resty.Response, ret dto.SchemaStatusResult, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_path := "/api/v1/pub/login/exit"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaStatusResult `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) ApiV1PubRefreshtoken(ctx context.Context, _headers map[string]string, options Options) (_resp *resty.Response, ret dto.SchemaLoginTokenInfo, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_path := "/api/v1/pub/refreshtoken"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaLoginTokenInfo `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) ApiV1Roles(ctx context.Context, _headers map[string]string, bodyJSON dto.SchemaRole, options Options) (_resp *resty.Response, ret dto.SchemaIDResult, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(bodyJSON)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(bodyJSON)
	}
	_path := "/api/v1/roles"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaIDResult `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) ApiV1Users(ctx context.Context, _headers map[string]string, bodyJSON dto.SchemaUser, options Options) (_resp *resty.Response, ret dto.SchemaIDResult, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(bodyJSON)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(bodyJSON)
	}
	_path := "/api/v1/users"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Post(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaIDResult `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) DeleteApiV1Menus_Id(ctx context.Context, _headers map[string]string, id int, options Options) (_resp *resty.Response, ret dto.SchemaStatusResult, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/api/v1/menus/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaStatusResult `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) DeleteApiV1Roles_Id(ctx context.Context, _headers map[string]string, id int, options Options) (_resp *resty.Response, ret dto.SchemaStatusResult, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/api/v1/roles/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaStatusResult `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) DeleteApiV1Users_Id(ctx context.Context, _headers map[string]string, id int, options Options) (_resp *resty.Response, ret dto.SchemaStatusResult, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/api/v1/users/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Delete(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaStatusResult `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) GetApiV1Menus(ctx context.Context, _headers map[string]string, current int, pageSize int, queryValue *string, status *int, isShow *int, parentID *int, options Options) (_resp *resty.Response, ret interface{}, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_urlValues.Set("current", fmt.Sprintf("%v", current))
	_urlValues.Set("pageSize", fmt.Sprintf("%v", pageSize))
	if queryValue != nil {
		_urlValues.Set("queryValue", fmt.Sprintf("%v", *queryValue))
	}
	if status != nil {
		_urlValues.Set("status", fmt.Sprintf("%v", *status))
	}
	if isShow != nil {
		_urlValues.Set("isShow", fmt.Sprintf("%v", *isShow))
	}
	if parentID != nil {
		_urlValues.Set("parentID", fmt.Sprintf("%v", *parentID))
	}
	_path := "/api/v1/menus"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret interface{} `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) GetApiV1Menus_Id(ctx context.Context, _headers map[string]string, id int, options Options) (_resp *resty.Response, ret dto.SchemaMenu, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/api/v1/menus/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaMenu `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) GetApiV1Menustree(ctx context.Context, _headers map[string]string, status *int, parentID *int, options Options) (_resp *resty.Response, ret interface{}, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if status != nil {
		_urlValues.Set("status", fmt.Sprintf("%v", *status))
	}
	if parentID != nil {
		_urlValues.Set("parentID", fmt.Sprintf("%v", *parentID))
	}
	_path := "/api/v1/menustree"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret interface{} `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) GetApiV1PubCurrentMenutree(ctx context.Context, _headers map[string]string, options Options) (_resp *resty.Response, ret interface{}, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_path := "/api/v1/pub/current/menutree"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret interface{} `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) GetApiV1PubCurrentUser(ctx context.Context, _headers map[string]string, options Options) (_resp *resty.Response, ret dto.SchemaUserLoginInfo, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_path := "/api/v1/pub/current/user"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaUserLoginInfo `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) GetApiV1PubLoginCaptcha(ctx context.Context, _headers map[string]string, id string, reload *string, options Options) (_resp *resty.Response, ret string, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_urlValues.Set("id", fmt.Sprintf("%v", id))
	if reload != nil {
		_urlValues.Set("reload", fmt.Sprintf("%v", *reload))
	}
	_path := "/api/v1/pub/login/captcha"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret string `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) GetApiV1PubLoginCaptchaid(ctx context.Context, _headers map[string]string, options Options) (_resp *resty.Response, ret dto.SchemaLoginCaptcha, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_path := "/api/v1/pub/login/captchaid"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaLoginCaptcha `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) GetApiV1Roles(ctx context.Context, _headers map[string]string, current int, pageSize int, queryValue *string, status *int, options Options) (_resp *resty.Response, ret interface{}, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_urlValues.Set("current", fmt.Sprintf("%v", current))
	_urlValues.Set("pageSize", fmt.Sprintf("%v", pageSize))
	if queryValue != nil {
		_urlValues.Set("queryValue", fmt.Sprintf("%v", *queryValue))
	}
	if status != nil {
		_urlValues.Set("status", fmt.Sprintf("%v", *status))
	}
	_path := "/api/v1/roles"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret interface{} `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) GetApiV1Roles_Id(ctx context.Context, _headers map[string]string, id int, options Options) (_resp *resty.Response, ret dto.SchemaRole, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/api/v1/roles/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaRole `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) GetApiV1Rolesselect(ctx context.Context, _headers map[string]string, queryValue *string, status *int, options Options) (_resp *resty.Response, ret interface{}, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if queryValue != nil {
		_urlValues.Set("queryValue", fmt.Sprintf("%v", *queryValue))
	}
	if status != nil {
		_urlValues.Set("status", fmt.Sprintf("%v", *status))
	}
	_path := "/api/v1/rolesselect"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret interface{} `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) GetApiV1Users(ctx context.Context, _headers map[string]string, current int, pageSize int, queryValue *string, roleIDs *string, status *int, options Options) (_resp *resty.Response, ret interface{}, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_urlValues.Set("current", fmt.Sprintf("%v", current))
	_urlValues.Set("pageSize", fmt.Sprintf("%v", pageSize))
	if queryValue != nil {
		_urlValues.Set("queryValue", fmt.Sprintf("%v", *queryValue))
	}
	if roleIDs != nil {
		_urlValues.Set("roleIDs", fmt.Sprintf("%v", *roleIDs))
	}
	if status != nil {
		_urlValues.Set("status", fmt.Sprintf("%v", *status))
	}
	_path := "/api/v1/users"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret interface{} `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) GetApiV1Users_Id(ctx context.Context, _headers map[string]string, id int, options Options) (_resp *resty.Response, ret dto.SchemaUser, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	_path := "/api/v1/users/{id}"
	_req.SetQueryParamsFromValues(_urlValues)
	_resp, _err = _req.Get(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaUser `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) PutApiV1Menus_Id(ctx context.Context, _headers map[string]string, id int, bodyJSON dto.SchemaMenu, options Options) (_resp *resty.Response, ret dto.SchemaStatusResult, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(bodyJSON)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(bodyJSON)
	}
	_path := "/api/v1/menus/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaStatusResult `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) PutApiV1PubCurrentPassword(ctx context.Context, _headers map[string]string, bodyJSON dto.SchemaUpdatePasswordParam, options Options) (_resp *resty.Response, ret dto.SchemaStatusResult, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(bodyJSON)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(bodyJSON)
	}
	_path := "/api/v1/pub/current/password"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaStatusResult `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) PutApiV1Roles_Id(ctx context.Context, _headers map[string]string, id int, bodyJSON dto.SchemaRole, options Options) (_resp *resty.Response, ret dto.SchemaRole, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(bodyJSON)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(bodyJSON)
	}
	_path := "/api/v1/roles/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaRole `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}
func (receiver *Gin2DoudouClient) PutApiV1Users_Id(ctx context.Context, _headers map[string]string, id int, bodyJSON dto.SchemaUser, options Options) (_resp *resty.Response, ret dto.SchemaUser, err error) {
	var _err error
	_urlValues := url.Values{}
	_req := receiver.client.R()
	if len(_headers) > 0 {
		_req.SetHeaders(_headers)
	}
	_req.SetContext(ctx)
	_req.SetPathParam("id", fmt.Sprintf("%v", id))
	if options.GzipReqBody {
		pr, pw := io.Pipe()
		go func() {
			gw := gzip.NewWriter(pw)
			_err = json.NewEncoder(gw).Encode(bodyJSON)
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			_err = gw.Close()
			if _err != nil {
				err = errors.Wrap(_err, "error")
				return
			}
			defer pw.CloseWithError(err)
		}()
		_req.SetHeader("Content-Type", "application/json")
		_req.SetHeader("Content-Encoding", "gzip")
		_req.SetBody(pr)
	} else {
		_req.SetBody(bodyJSON)
	}
	_path := "/api/v1/users/{id}"
	if _req.Body != nil {
		_req.SetQueryParamsFromValues(_urlValues)
	} else {
		_req.SetFormDataFromValues(_urlValues)
	}
	_resp, _err = _req.Put(_path)
	if _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	if _resp.IsError() {
		err = errors.New(_resp.String())
		return
	}
	var _result struct {
		Ret dto.SchemaUser `json:"ret"`
	}
	if _err = json.Unmarshal(_resp.Body(), &_result); _err != nil {
		err = errors.Wrap(_err, "error")
		return
	}
	return _resp, _result.Ret, nil
}

func NewGin2DoudouClient(opts ...restclient.RestClientOption) *Gin2DoudouClient {
	defaultProvider := restclient.NewServiceProvider("GIN2DOUDOU")
	defaultClient := restclient.NewClient()

	svcClient := &Gin2DoudouClient{
		provider: defaultProvider,
		client:   defaultClient,
	}

	for _, opt := range opts {
		opt(svcClient)
	}

	svcClient.client.OnBeforeRequest(func(_ *resty.Client, request *resty.Request) error {
		request.URL = svcClient.provider.SelectServer() + svcClient.rootPath + request.URL
		return nil
	})

	svcClient.client.SetPreRequestHook(func(_ *resty.Client, request *http.Request) error {
		traceReq, _ := nethttp.TraceRequest(opentracing.GlobalTracer(), request,
			nethttp.OperationName(fmt.Sprintf("HTTP %s: %s", request.Method, request.URL.Path)))
		*request = *traceReq
		return nil
	})

	svcClient.client.OnAfterResponse(func(_ *resty.Client, response *resty.Response) error {
		nethttp.TracerFromRequest(response.Request.RawRequest).Finish()
		return nil
	})

	return svcClient
}
