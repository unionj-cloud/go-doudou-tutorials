/**
* Generated by go-doudou v2.0.5.
* You can edit it as your need.
 */
package client

import (
	"context"
	"gin2doudou/dto"
	"time"

	"github.com/go-resty/resty/v2"
	"github.com/pkg/errors"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/rs/zerolog"
	"github.com/slok/goresilience"
	"github.com/slok/goresilience/circuitbreaker"
	rerrors "github.com/slok/goresilience/errors"
	"github.com/slok/goresilience/metrics"
	"github.com/slok/goresilience/retry"
	"github.com/slok/goresilience/timeout"
	"github.com/unionj-cloud/go-doudou/v2/toolkit/zlogger"
)

type Gin2DoudouClientProxy struct {
	client *Gin2DoudouClient
	logger zerolog.Logger
	runner goresilience.Runner
}

func (receiver *Gin2DoudouClientProxy) ApiV1Menus(ctx context.Context, _headers map[string]string, bodyJSON dto.SchemaMenu, options Options) (_resp *resty.Response, ret dto.SchemaIDResult, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.ApiV1Menus(
			ctx,
			_headers,
			bodyJSON,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call ApiV1Menus fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call ApiV1Menus fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) ApiV1PubLogin(ctx context.Context, _headers map[string]string, bodyJSON dto.SchemaLoginParam, options Options) (_resp *resty.Response, ret dto.SchemaLoginTokenInfo, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.ApiV1PubLogin(
			ctx,
			_headers,
			bodyJSON,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call ApiV1PubLogin fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call ApiV1PubLogin fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) ApiV1PubLoginExit(ctx context.Context, _headers map[string]string, options Options) (_resp *resty.Response, ret dto.SchemaStatusResult, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.ApiV1PubLoginExit(
			ctx,
			_headers,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call ApiV1PubLoginExit fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call ApiV1PubLoginExit fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) ApiV1PubRefreshtoken(ctx context.Context, _headers map[string]string, options Options) (_resp *resty.Response, ret dto.SchemaLoginTokenInfo, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.ApiV1PubRefreshtoken(
			ctx,
			_headers,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call ApiV1PubRefreshtoken fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call ApiV1PubRefreshtoken fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) ApiV1Roles(ctx context.Context, _headers map[string]string, bodyJSON dto.SchemaRole, options Options) (_resp *resty.Response, ret dto.SchemaIDResult, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.ApiV1Roles(
			ctx,
			_headers,
			bodyJSON,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call ApiV1Roles fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call ApiV1Roles fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) ApiV1Users(ctx context.Context, _headers map[string]string, bodyJSON dto.SchemaUser, options Options) (_resp *resty.Response, ret dto.SchemaIDResult, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.ApiV1Users(
			ctx,
			_headers,
			bodyJSON,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call ApiV1Users fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call ApiV1Users fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) DeleteApiV1Menus_Id(ctx context.Context, _headers map[string]string, id int, options Options) (_resp *resty.Response, ret dto.SchemaStatusResult, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.DeleteApiV1Menus_Id(
			ctx,
			_headers,
			id,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call DeleteApiV1Menus_Id fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call DeleteApiV1Menus_Id fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) DeleteApiV1Roles_Id(ctx context.Context, _headers map[string]string, id int, options Options) (_resp *resty.Response, ret dto.SchemaStatusResult, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.DeleteApiV1Roles_Id(
			ctx,
			_headers,
			id,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call DeleteApiV1Roles_Id fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call DeleteApiV1Roles_Id fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) DeleteApiV1Users_Id(ctx context.Context, _headers map[string]string, id int, options Options) (_resp *resty.Response, ret dto.SchemaStatusResult, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.DeleteApiV1Users_Id(
			ctx,
			_headers,
			id,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call DeleteApiV1Users_Id fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call DeleteApiV1Users_Id fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) GetApiV1Menus(ctx context.Context, _headers map[string]string, current int, pageSize int, queryValue *string, status *int, isShow *int, parentID *int, options Options) (_resp *resty.Response, ret interface{}, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.GetApiV1Menus(
			ctx,
			_headers,
			current,
			pageSize,
			queryValue,
			status,
			isShow,
			parentID,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call GetApiV1Menus fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetApiV1Menus fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) GetApiV1Menus_Id(ctx context.Context, _headers map[string]string, id int, options Options) (_resp *resty.Response, ret dto.SchemaMenu, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.GetApiV1Menus_Id(
			ctx,
			_headers,
			id,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call GetApiV1Menus_Id fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetApiV1Menus_Id fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) GetApiV1Menustree(ctx context.Context, _headers map[string]string, status *int, parentID *int, options Options) (_resp *resty.Response, ret interface{}, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.GetApiV1Menustree(
			ctx,
			_headers,
			status,
			parentID,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call GetApiV1Menustree fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetApiV1Menustree fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) GetApiV1PubCurrentMenutree(ctx context.Context, _headers map[string]string, options Options) (_resp *resty.Response, ret interface{}, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.GetApiV1PubCurrentMenutree(
			ctx,
			_headers,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call GetApiV1PubCurrentMenutree fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetApiV1PubCurrentMenutree fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) GetApiV1PubCurrentUser(ctx context.Context, _headers map[string]string, options Options) (_resp *resty.Response, ret dto.SchemaUserLoginInfo, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.GetApiV1PubCurrentUser(
			ctx,
			_headers,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call GetApiV1PubCurrentUser fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetApiV1PubCurrentUser fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) GetApiV1PubLoginCaptcha(ctx context.Context, _headers map[string]string, id string, reload *string, options Options) (_resp *resty.Response, ret string, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.GetApiV1PubLoginCaptcha(
			ctx,
			_headers,
			id,
			reload,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call GetApiV1PubLoginCaptcha fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetApiV1PubLoginCaptcha fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) GetApiV1PubLoginCaptchaid(ctx context.Context, _headers map[string]string, options Options) (_resp *resty.Response, ret dto.SchemaLoginCaptcha, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.GetApiV1PubLoginCaptchaid(
			ctx,
			_headers,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call GetApiV1PubLoginCaptchaid fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetApiV1PubLoginCaptchaid fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) GetApiV1Roles(ctx context.Context, _headers map[string]string, current int, pageSize int, queryValue *string, status *int, options Options) (_resp *resty.Response, ret interface{}, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.GetApiV1Roles(
			ctx,
			_headers,
			current,
			pageSize,
			queryValue,
			status,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call GetApiV1Roles fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetApiV1Roles fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) GetApiV1Roles_Id(ctx context.Context, _headers map[string]string, id int, options Options) (_resp *resty.Response, ret dto.SchemaRole, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.GetApiV1Roles_Id(
			ctx,
			_headers,
			id,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call GetApiV1Roles_Id fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetApiV1Roles_Id fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) GetApiV1Rolesselect(ctx context.Context, _headers map[string]string, queryValue *string, status *int, options Options) (_resp *resty.Response, ret interface{}, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.GetApiV1Rolesselect(
			ctx,
			_headers,
			queryValue,
			status,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call GetApiV1Rolesselect fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetApiV1Rolesselect fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) GetApiV1Users(ctx context.Context, _headers map[string]string, current int, pageSize int, queryValue *string, roleIDs *string, status *int, options Options) (_resp *resty.Response, ret interface{}, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.GetApiV1Users(
			ctx,
			_headers,
			current,
			pageSize,
			queryValue,
			roleIDs,
			status,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call GetApiV1Users fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetApiV1Users fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) GetApiV1Users_Id(ctx context.Context, _headers map[string]string, id int, options Options) (_resp *resty.Response, ret dto.SchemaUser, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.GetApiV1Users_Id(
			ctx,
			_headers,
			id,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call GetApiV1Users_Id fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call GetApiV1Users_Id fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) PutApiV1Menus_Id(ctx context.Context, _headers map[string]string, id int, bodyJSON dto.SchemaMenu, options Options) (_resp *resty.Response, ret dto.SchemaStatusResult, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.PutApiV1Menus_Id(
			ctx,
			_headers,
			id,
			bodyJSON,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call PutApiV1Menus_Id fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call PutApiV1Menus_Id fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) PutApiV1PubCurrentPassword(ctx context.Context, _headers map[string]string, bodyJSON dto.SchemaUpdatePasswordParam, options Options) (_resp *resty.Response, ret dto.SchemaStatusResult, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.PutApiV1PubCurrentPassword(
			ctx,
			_headers,
			bodyJSON,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call PutApiV1PubCurrentPassword fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call PutApiV1PubCurrentPassword fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) PutApiV1Roles_Id(ctx context.Context, _headers map[string]string, id int, bodyJSON dto.SchemaRole, options Options) (_resp *resty.Response, ret dto.SchemaRole, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.PutApiV1Roles_Id(
			ctx,
			_headers,
			id,
			bodyJSON,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call PutApiV1Roles_Id fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call PutApiV1Roles_Id fail")
	}
	return
}
func (receiver *Gin2DoudouClientProxy) PutApiV1Users_Id(ctx context.Context, _headers map[string]string, id int, bodyJSON dto.SchemaUser, options Options) (_resp *resty.Response, ret dto.SchemaUser, err error) {
	if _err := receiver.runner.Run(ctx, func(ctx context.Context) error {
		_resp, ret, err = receiver.client.PutApiV1Users_Id(
			ctx,
			_headers,
			id,
			bodyJSON,
			options,
		)
		if err != nil {
			return errors.Wrap(err, "call PutApiV1Users_Id fail")
		}
		return nil
	}); _err != nil {
		// you can implement your fallback logic here
		if errors.Is(_err, rerrors.ErrCircuitOpen) {
			receiver.logger.Error().Err(_err).Msg("")
		}
		err = errors.Wrap(_err, "call PutApiV1Users_Id fail")
	}
	return
}

type ProxyOption func(*Gin2DoudouClientProxy)

func WithRunner(runner goresilience.Runner) ProxyOption {
	return func(proxy *Gin2DoudouClientProxy) {
		proxy.runner = runner
	}
}

func WithLogger(logger zerolog.Logger) ProxyOption {
	return func(proxy *Gin2DoudouClientProxy) {
		proxy.logger = logger
	}
}

func NewGin2DoudouClientProxy(client *Gin2DoudouClient, opts ...ProxyOption) *Gin2DoudouClientProxy {
	cp := &Gin2DoudouClientProxy{
		client: client,
		logger: zlogger.Logger,
	}

	for _, opt := range opts {
		opt(cp)
	}

	if cp.runner == nil {
		var mid []goresilience.Middleware
		mid = append(mid, metrics.NewMiddleware("gin2doudou_client", metrics.NewPrometheusRecorder(prometheus.DefaultRegisterer)))
		mid = append(mid, circuitbreaker.NewMiddleware(circuitbreaker.Config{
			ErrorPercentThresholdToOpen:        50,
			MinimumRequestToOpen:               6,
			SuccessfulRequiredOnHalfOpen:       1,
			WaitDurationInOpenState:            5 * time.Second,
			MetricsSlidingWindowBucketQuantity: 10,
			MetricsBucketDuration:              1 * time.Second,
		}),
			timeout.NewMiddleware(timeout.Config{
				Timeout: 3 * time.Minute,
			}),
			retry.NewMiddleware(retry.Config{
				Times: 3,
			}))

		cp.runner = goresilience.RunnerChain(mid...)
	}

	return cp
}
