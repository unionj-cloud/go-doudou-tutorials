// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"github.com/unionj-cloud/go-doudou/v2/toolkit/gormgen"
	"github.com/unionj-cloud/go-doudou/v2/toolkit/gormgen/field"

	"gorm.io/plugin/dbresolver"

	"testgggorm2/model"
)

func newProductColor(db *gorm.DB, opts ...gormgen.DOOption) productColor {
	_productColor := productColor{}

	_productColor.productColorDo.UseDB(db, opts...)
	_productColor.productColorDo.UseModel(&model.ProductColor{})

	tableName := _productColor.productColorDo.TableName()
	_productColor.ALL = field.NewAsterisk(tableName)
	_productColor.ID = field.NewInt32(tableName, "id")
	_productColor.ColorName = field.NewString(tableName, "color_name")
	_productColor.ColorValue = field.NewString(tableName, "color_value")
	_productColor.Status = field.NewInt32(tableName, "status")
	_productColor.Checked = field.NewInt32(tableName, "checked")

	_productColor.fillFieldMap()

	return _productColor
}

type productColor struct {
	productColorDo productColorDo

	ALL        field.Asterisk
	ID         field.Int32
	ColorName  field.String // 颜色名字
	ColorValue field.String // 颜色值
	Status     field.Int32  // 状态
	Checked    field.Int32  // 是否检验

	fieldMap map[string]field.Expr
}

func (p productColor) Table(newTableName string) *productColor {
	p.productColorDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p productColor) As(alias string) *productColor {
	p.productColorDo.DO = *(p.productColorDo.As(alias).(*gormgen.DO))
	return p.updateTableName(alias)
}

func (p *productColor) updateTableName(table string) *productColor {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewInt32(table, "id")
	p.ColorName = field.NewString(table, "color_name")
	p.ColorValue = field.NewString(table, "color_value")
	p.Status = field.NewInt32(table, "status")
	p.Checked = field.NewInt32(table, "checked")

	p.fillFieldMap()

	return p
}

func (p *productColor) WithContext(ctx context.Context) IProductColorDo {
	return p.productColorDo.WithContext(ctx)
}

func (p productColor) TableName() string { return p.productColorDo.TableName() }

func (p productColor) Alias() string { return p.productColorDo.Alias() }

func (p productColor) Columns(cols ...field.Expr) gormgen.Columns {
	return p.productColorDo.Columns(cols...)
}

func (p *productColor) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *productColor) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 5)
	p.fieldMap["id"] = p.ID
	p.fieldMap["color_name"] = p.ColorName
	p.fieldMap["color_value"] = p.ColorValue
	p.fieldMap["status"] = p.Status
	p.fieldMap["checked"] = p.Checked
}

func (p productColor) clone(db *gorm.DB) productColor {
	p.productColorDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p productColor) replaceDB(db *gorm.DB) productColor {
	p.productColorDo.ReplaceDB(db)
	return p
}

type productColorDo struct{ gormgen.DO }

type IProductColorDo interface {
	gormgen.SubQuery
	Debug() IProductColorDo
	WithContext(ctx context.Context) IProductColorDo
	WithResult(fc func(tx gormgen.Dao)) gormgen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IProductColorDo
	WriteDB() IProductColorDo
	As(alias string) gormgen.Dao
	Session(config *gorm.Session) IProductColorDo
	Columns(cols ...field.Expr) gormgen.Columns
	Clauses(conds ...clause.Expression) IProductColorDo
	Not(conds ...gormgen.Condition) IProductColorDo
	Or(conds ...gormgen.Condition) IProductColorDo
	Select(conds ...field.Expr) IProductColorDo
	Where(conds ...gormgen.Condition) IProductColorDo
	Order(conds ...field.Expr) IProductColorDo
	Distinct(cols ...field.Expr) IProductColorDo
	Omit(cols ...field.Expr) IProductColorDo
	Join(table schema.Tabler, on ...field.Expr) IProductColorDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IProductColorDo
	RightJoin(table schema.Tabler, on ...field.Expr) IProductColorDo
	Group(cols ...field.Expr) IProductColorDo
	Having(conds ...gormgen.Condition) IProductColorDo
	Limit(limit int) IProductColorDo
	Offset(offset int) IProductColorDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gormgen.Dao) gormgen.Dao) IProductColorDo
	Unscoped() IProductColorDo
	Create(values ...*model.ProductColor) error
	CreateInBatches(values []*model.ProductColor, batchSize int) error
	Save(values ...*model.ProductColor) error
	First() (*model.ProductColor, error)
	Take() (*model.ProductColor, error)
	Last() (*model.ProductColor, error)
	Find() ([]*model.ProductColor, error)
	FindInBatch(batchSize int, fc func(tx gormgen.Dao, batch int) error) (results []*model.ProductColor, err error)
	FindInBatches(result *[]*model.ProductColor, batchSize int, fc func(tx gormgen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ProductColor) (info gormgen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gormgen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gormgen.ResultInfo, err error)
	Updates(value interface{}) (info gormgen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gormgen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gormgen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gormgen.ResultInfo, err error)
	UpdateFrom(q gormgen.SubQuery) gormgen.Dao
	Attrs(attrs ...field.AssignExpr) IProductColorDo
	Assign(attrs ...field.AssignExpr) IProductColorDo
	Joins(fields ...field.RelationField) IProductColorDo
	Preload(fields ...field.RelationField) IProductColorDo
	FirstOrInit() (*model.ProductColor, error)
	FirstOrCreate() (*model.ProductColor, error)
	FindByPage(offset int, limit int) (result []*model.ProductColor, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IProductColorDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p productColorDo) Debug() IProductColorDo {
	return p.withDO(p.DO.Debug())
}

func (p productColorDo) WithContext(ctx context.Context) IProductColorDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p productColorDo) ReadDB() IProductColorDo {
	return p.Clauses(dbresolver.Read)
}

func (p productColorDo) WriteDB() IProductColorDo {
	return p.Clauses(dbresolver.Write)
}

func (p productColorDo) Session(config *gorm.Session) IProductColorDo {
	return p.withDO(p.DO.Session(config))
}

func (p productColorDo) Clauses(conds ...clause.Expression) IProductColorDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p productColorDo) Returning(value interface{}, columns ...string) IProductColorDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p productColorDo) Not(conds ...gormgen.Condition) IProductColorDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p productColorDo) Or(conds ...gormgen.Condition) IProductColorDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p productColorDo) Select(conds ...field.Expr) IProductColorDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p productColorDo) Where(conds ...gormgen.Condition) IProductColorDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p productColorDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IProductColorDo {
	return p.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (p productColorDo) Order(conds ...field.Expr) IProductColorDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p productColorDo) Distinct(cols ...field.Expr) IProductColorDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p productColorDo) Omit(cols ...field.Expr) IProductColorDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p productColorDo) Join(table schema.Tabler, on ...field.Expr) IProductColorDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p productColorDo) LeftJoin(table schema.Tabler, on ...field.Expr) IProductColorDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p productColorDo) RightJoin(table schema.Tabler, on ...field.Expr) IProductColorDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p productColorDo) Group(cols ...field.Expr) IProductColorDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p productColorDo) Having(conds ...gormgen.Condition) IProductColorDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p productColorDo) Limit(limit int) IProductColorDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p productColorDo) Offset(offset int) IProductColorDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p productColorDo) Scopes(funcs ...func(gormgen.Dao) gormgen.Dao) IProductColorDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p productColorDo) Unscoped() IProductColorDo {
	return p.withDO(p.DO.Unscoped())
}

func (p productColorDo) Create(values ...*model.ProductColor) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p productColorDo) CreateInBatches(values []*model.ProductColor, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p productColorDo) Save(values ...*model.ProductColor) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p productColorDo) First() (*model.ProductColor, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductColor), nil
	}
}

func (p productColorDo) Take() (*model.ProductColor, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductColor), nil
	}
}

func (p productColorDo) Last() (*model.ProductColor, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductColor), nil
	}
}

func (p productColorDo) Find() ([]*model.ProductColor, error) {
	result, err := p.DO.Find()
	return result.([]*model.ProductColor), err
}

func (p productColorDo) FindInBatch(batchSize int, fc func(tx gormgen.Dao, batch int) error) (results []*model.ProductColor, err error) {
	buf := make([]*model.ProductColor, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gormgen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p productColorDo) FindInBatches(result *[]*model.ProductColor, batchSize int, fc func(tx gormgen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p productColorDo) Attrs(attrs ...field.AssignExpr) IProductColorDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p productColorDo) Assign(attrs ...field.AssignExpr) IProductColorDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p productColorDo) Joins(fields ...field.RelationField) IProductColorDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p productColorDo) Preload(fields ...field.RelationField) IProductColorDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p productColorDo) FirstOrInit() (*model.ProductColor, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductColor), nil
	}
}

func (p productColorDo) FirstOrCreate() (*model.ProductColor, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductColor), nil
	}
}

func (p productColorDo) FindByPage(offset int, limit int) (result []*model.ProductColor, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p productColorDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p productColorDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p productColorDo) Delete(models ...*model.ProductColor) (result gormgen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *productColorDo) withDO(do gormgen.Dao) *productColorDo {
	p.DO = *do.(*gormgen.DO)
	return p
}
